# 1.3 程序开发与执行过程

## 前言

1. 程序的开发和执行计算机系统的各个不同层面
2. 程序被称为用户程序(user program)或应用程序(application program)

## 1.3.1 从源程序到可执行程序

以下是hello.c的C语言 源程序代码

`#include<stdio.h>`

`int main()`

`{`

​	`printf("hello world!\n");`

`}`

1. 通过程序编辑软件得到hello.c文件，如第一个字节的值是35，代表字符'#'；通常用ASCII码字符或汉字字符表示的文件称为**文本文件**(text file)，**源程序文件都是文本文件**，是可显示和可读的

2. 将hello.c进行 预处理，编译，汇编和链接，最终生成可执行目标文件；在UNIX系统中，可用GCC编译驱动程序进行处理，命令如下：

   `unix> gcc -o hello hello.c`

   gcc为GCC编译驱动程序名，-o表示后面为输出文件名，hello.c为要处理的源程序

   ### hello.c源程序文件到可执行文件的转换过程

   1. 预处理阶段：**预处理程序(cpp)对源程序中以字符#开头的命令进行处理**；例如：将#include命令后面的.h文件内容嵌入放到源程序中(#define #endif)；预处理程序的输出结果还是一个源程序文件，以.i为扩展名
   2. 编译阶段：编译程序(ccl) 对预处理后的源程序进行编译，生成一个汇编语言程序文件以.s为扩展名；例如：hello.s是一个汇编语言程序文件；**因为汇编语言与具体的机器结构有关**，所以，对于同一台机器来说，**不管使用上面高级语言，编译转换过后的输出结果使用都是同一种机器级代码**
   3. 汇编阶段：汇编程序(as) 对汇编语言源程序进行汇编，生成一个可重定位目标文件(relocatable object file)，以.o为扩展名，例如：hello.o是一个可重定位目标文件；它是一种二进制文件(binary file)，因为其中的代码已经是机器指令，数据以及其他信息也都是二进制表示的，所以它是不可读的，也即显示出来的是乱码
   4. 链接阶段：链接程序(ld) 将多个可重定位目标文件和标准库函数合并成为一个可执行目标文件(executable object file)，**可执行目标文件可简称为：可执行文件**，本例中：链接程序将hello.o和标准库printf所在的可重定位目标模块printf.o进行合并，生成可执行文件hello
   5. **最终生成的可执行文件被保存在磁盘上**，可以通过某种方式启动一个磁盘上的可执行文件运行

   

## 1.3.2 可执行文件的启动与执行

- Windows双击对应图标;Linux | Unix 在命令行中输入可执行文件名等多种方式启动执行

- 启动和执行hello程序的整个过程

1. shell程序会将用户从键盘输入的每个字符逐一读入CPU寄存器中，然后再保存到主存储器中，在主存的缓冲区形成字符串"./hello"
2. 等到接到[Enter]按键时；shell将调出的操作系统内核中相应的服务例程，由内核来加载磁盘上的可执行文件hello到存储器
3. 内核加载完可执行文件中的代码机器所要处理的数据(这里时字符串"hello world!\n")后，将hello第一条指令的地址送到**程序计数器(Program Counter，简称PC)**
4. CPU永远都是将PC的内容作为将要执行的指令的地址，因此处理器随后开始执行hello程序，它将加载到主存的字符串"hello world!\n"中的每一个字符从主存取到CPU的寄存器中，然后将CPU寄存器中的字符送到显示器上显示出来

————————————————————————————————————————————————————————————————————————————————————

1. 从上述过程中可以看出，一个用户程序被启动执行，必须依靠操作系统的支持，包括外壳程序和内核服务例程；
2. 例如shell命令行解释器时操作系统外壳程序，它为用户提供了一个启动程序执行的环境，对用户从键盘输入的命令进行解释，并调出操作系统内核来加载用户程序(用户输入命令对应的程序)
3. 用来加载用户程序并使其从第一条指令开始执行的操作系统内核服务例程也是必不可少的
4. 在上述过程中，设计键盘，磁盘和显示器等外部设施例程的支持；例如：用户程序需要调用内核的read系统服务历程读取磁盘文件，或调用内核的write系统调用服务把字符串写道显示器中等

总结：

- 程序的执行过程就是数据在CPU，主存储器和I/O模块之间流动的过程
- 所有数据的流动都是通过总线，I/O桥接器等进行的
- 数据在总线上传输之前，需要先缓存在存储部件中，因此，除了主存储器本身是存储部件以外
- 在CPU，I/O桥接器，设备控制器中也有存放数据的缓冲存储部件
- 例如：CPU中的寄存器堆，设备控制器中的数据缓冲寄存器

## 1.3.3 程序中每条指令的执行

1. 每个可执行目标文件中都包含程序代码段，可执行文件的执行实际上是对应的程序代码段执行的过程

2. 程序代码由一条一条机器指令构成

3. 指令(instruction)是用0和1表示的一串0/1序列，用来指示CPU完成一个特定的原子操作：

   (1)：**取数指令(load instruction)**从存储单元中取出一个数据存放到CPU寄存器中

   (2)：**存数指令(store instruction)**将CPU寄存器的内容写入一个存储单元

   (3)：**ALU指令(ALU instruction)**将两个寄存器内容惊醒某种算术或逻辑运算后再送入一个CPU寄存器中

   (4)：**输出指令(output instruction)**，将一个CPU寄存器的内容送到I/O模块的某个缓存器中

4. 在上述hello程序中，字符串"hello world!\n"中的每一个字符都要通过取数指令从存储器送到CPU寄存器中，然后，再通过输出指令从CPU寄存器送到显示器适配器(也称显示控制器)中

————————————————————————————————————————————————————————————————————————————————————

1. 指令通常被划分为若干字段，由操作码字段，地址码字段和立即数字段等

   (1)**操作码字段：**指出指令的**操作类型**，如加，减，传送，跳转等

   (2)**地址码字段：**指出指令所处理的操作数的**地址**，如寄存器编号，内存单元地址等

   (3)**立即数字段：**指出**具体**的一个**操作数**或偏移量

2. 《计算机系统基础》p14 图1.9中：给出了实现**两个相邻数组元素交换功能的不同层次语言的描述**

3. 在高级语言源程序中，可直观地用三个赋值语句实现

   `temp=v[k];`

   `v[k]=v[k+1];`

   `v[k+1]=temp;`

4. 在经编译后生成的汇编语言源程序中，可用4个汇编指令表示，其中两条是取数指令**lw(load word)**

   另两条是**存数指令sw(store word)**

   **编译后的程序后的结果：**

   `lw $15,0($2)`

   `lw $16,4($2)`

   `sw $16,0($2)`

   `sw $15,4($2)`

5. 在经汇编后生成的机器语言程序中，对应的机器指令是特定格式的二进制代码；

   例如：第一条lw指令对应机器代码为"1000 1100 0100 1111 0000 0000 0000 0000"

   **这是一条MIPS(指令集架构)体系结构中的指令**，其中，【高6位 “100011”位操作码，随后5位"00010"为寄存器编号2，再后面5位"01111"为另一个寄存器编号，最后16位表示立即数0】

6. **CPU能够通过逻辑电路直接执行这种二进制表示的机器指令**；指令执行时通过控制器堆指令操作码进行译码，解释成**控制信号(control signal)**<u>控制数据通路执行</u>；

   例如：

   控制信号ALUop=add可以控制ALU进行加法操作，RegWr可以控制将结果写入寄存器中

   ……,EXTop=1,ALUSelA=1,ALUSelB=ll……………………

—————————————————————————————————————————————————————————————————————————————————————

1. 每条指令的执行过程包括：从存储器取指令并计算下一条指令的地址，对指令进行译码，取操作数，对操作数运算，送运算结果到存储器或寄存器保存
2. 每次从存储器取指令都是将PC的值作为指令的地址，因此，计算处的下条要执行指令的地址被送到PC，当前指令执行完后，根据PC的值到存储器去取下条指令，从而能够周而复始地执行程序中地每条指令
3. 指令地执行由时钟信号(clock signal)进行定时，一条指令的执行可能需要一个或多个时钟的时间